{"name":"KVS","tagline":"Erlang Data Framework with Sequential Consistency","body":"KVS: Erlang Abstract Term Database\r\n==================================\r\n\r\nOnline Presentation: http://slid.es/maximsokhatsky/kvs\r\n\r\nFeatures\r\n--------\r\n\r\n* Polymorphic Tuples\r\n* Managing Linked-Lists\r\n* Various Backends Support: Mnesia, Riak, KAI, Redis\r\n* Sequential Consistency via Feed Server\r\n* Basic Schema for Social Sites and Accounting\r\n* Extendable Schema\r\n* Supports Secondary Indexes for KAI, Mnesia and Riak\r\n* Change Backends on-the-fly\r\n* Supports Multiple backends at the same time\r\n* Xen Ready\r\n\r\nUsage\r\n-----\r\n\r\nIn rebar.config:\r\n\r\n```erlang\r\n    {kvs, \".*\", {git, \"git://github.com/synrc/kvs\", \"HEAD\"}}\r\n```\r\n\r\nRedis also need to add:\r\n```erlang\r\n    {eredis, \".*\", {git, \"git://github.com/wooga/eredis\", {tag, \"v1.0.6\"} }}\r\n```\r\n\r\nOverview\r\n--------\r\n\r\nThis is database handling application that hides database access\r\nand provides high-level rich API to stored and extend following data:\r\n\r\nKVS\r\n\r\n* Acl\r\n* Users\r\n* Subscriptions\r\n* Feeds\r\n* Entries\r\n* Comments\r\n\r\nKVS SOCIAL\r\n\r\n* Groups\r\n* Meetings\r\n* Accounts\r\n* Payments\r\n* Products\r\n* Purchases\r\n\r\nThis Framework provides also a Feed Server Plugin for sequential consistency.\r\nAll write requests with given object key will be handled by single processes\r\nin Feed Server so you may not worry about concurrent changes of user feed tops.\r\n\r\nAll write operations that are made to data with secondary indexes,\r\ni.e. not like linked lists could be potentially handled without feed_server.\r\nBut some KV storages are not supporting secondary indexes add those backends carefully.\r\n\r\nStore Backends\r\n--------------\r\n\r\nCurrently kvs includes following store backends:\r\n\r\n* Mnesia\r\n* Riak\r\n* KAI\r\n* Redis\r\n\r\nConfiguring\r\n-----------\r\n\r\nFirst of all you need to tune your backend in the kvs application:\r\n\r\n```erlang\r\n{kvs, [{dba,store_mnesia}]},\r\n```\r\n\r\nTry to check it:\r\n\r\n```erlang\r\n1> kvs:config(dba).\r\nstore_kai\r\n\r\n2> kvs:version().\r\n{version,\"KVS KAI PURE XEN\"}\r\n```\r\n\r\nCreate database for single node:\r\n\r\n```erlang\r\n3> kvs:join().\r\n[kvs] Mnesia Init\r\nok\r\n```\r\n\r\nYou can also create database by joining to existing cluster:\r\n\r\n```erlang\r\n3> kvs:join('kvs@synrc.com').\r\n```\r\n\r\nIn that case you don't need to do 'init_db'\r\nTo check table packages included into the schema:\r\n\r\n```erlang\r\n4> kvs:dir().\r\n[{table,\"id_seq\"},\r\n {table,\"subscription\"}, <- 2i\r\n {table,\"feed\"}, <- feed\r\n {table,\"comment\"},\r\n {table,\"entry\"},\r\n {table,\"access\"},\r\n {table,\"acl\"}, <- feed\r\n {table,\"user\"}]\r\n```\r\n\r\nOperations\r\n----------\r\n\r\nTry to add some data:\r\n\r\n```erlang\r\n1> rr(kvs).\r\n2> kvs:put(#user{id=\"maxim@synrc.com\"}).\r\nok\r\n3> kvs:get(user,\"maxim@synrc.com\").\r\n#user{id = \"maxim@synrc.com\",container = feed,...}\r\n4> kvs:put(#user{id=\"doxtop@synrc.com\"}).\r\n5> length(kvs:all(user)).\r\n2\r\n```\r\n\r\nPolymorphic Records\r\n-------------------\r\n\r\nThe data in KVS represented as plain Erlang records. The first element of the tuple\r\nas usual indicates the name of bucket. And the second element usually corresponds\r\nto the index key field. Additional secondary indexes could be applied for stores\r\nthat supports 2i, e.g. kai, mnesia, riak.\r\n\r\nIterators\r\n---------\r\n\r\nAll record could be chained into the double-linked lists in the database.\r\nSo you can inherit from the ITERATOR record just like that:\r\n\r\n```erlang\r\n-record(iterator, {id,version,\r\n                   container,feed_id,prev,\r\n                   next,feeds=[],guard,etc}).\r\n```\r\n\r\nThe layout of iterators are following:\r\n\r\n```erlang\r\n> lists:zip(lists:seq(1,length((kvs:table(operation))#table.fields)),\r\n            (kvs:table(operation))#table.fields).\r\n\r\n[{1,id},\r\n {2,version},\r\n {3,container},\r\n {4,feed_id},\r\n {5,prev},\r\n {6,next},\r\n {7,feeds},\r\n {8,guard},\r\n {9,etc},\r\n {10,body},\r\n {11,name},\r\n {12,status}]\r\n```\r\n\r\nThis means your table will support add/remove linked list operations to lists.\r\n\r\n```erlang\r\n1> kvs:add(#user{id=\"mes@ua.fm\"}).\r\n2> kvs:add(#user{id=\"dox@ua.fm\"}).\r\n```\r\n\r\nRead the chain (undefined means all)\r\n\r\n```erlang\r\n3> kvs:entries(kvs:get(feed, user), user, undefined).\r\n[#user{id=\"mes@ua.fm\"},\r\n #user{id=\"dox@ua.fm\"}]\r\n```\r\n\r\nRead flat values by all keys from table:\r\n\r\n```erlang\r\n4> kvs:all(user).\r\n[#user{id=\"mes@ua.fm\"},\r\n #user{id=\"dox@ua.fm\"}]\r\n```\r\n\r\nContainers\r\n----------\r\n\r\nIf you are using iterators records this automatically means you are using containers.\r\nContainers are just boxes for storing top/heads of the linked lists. Here is layout\r\nof containers:\r\n\r\n```erlang\r\n-record(container, {id,top,count}).\r\n```\r\n\r\n```erlang\r\n> lists:zip(lists:seq(1,length((kvs:table(feed))#table.fields)),\r\n            (kvs:table(feed))#table.fields).\r\n[{1,id},\r\n {2,top},\r\n {3,count},\r\n {4,aclver}]\r\n```\r\n\r\nExtending Schema\r\n----------------\r\n\r\nUsually you need only specify custom mnesia indexes and tables tuning.\r\nRiak, KAI and Redis backends don't need it. Group you table into table packages\r\nrepresented as modules with handle_notice API.\r\n\r\n```erlang\r\n-module(kvs_feed).\r\n-inclue_lib(\"kvs/include/kvs.hrl\").\r\n\r\nmetainfo() -> \r\n    #schema{name=kvs,tables=[\r\n        #table{name=feed,container=true,fields=record_info(fields,feed)},\r\n        #table{ name=entry,container=feed,fields=record_info(fields,entry),\r\n                keys=[feed_id,entry_id,from]},\r\n        #table{name=comment,container=feed,fields=record_info(fields,comment),\r\n                keys=[entry_id,author_id]} ]}.\r\n```\r\n\r\nAnd plug it into schema config:\r\n\r\n```erlang\r\n{kvs, {schema,[kvs_user,kvs_acl,kvs_feed,kvs_subscription]}},\r\n```\r\n\r\nAnd on database init\r\n\r\n```erlang\r\n1> kvs:join().\r\n```\r\n\r\nIt will create your custom schema.\r\n\r\nBusiness Logic\r\n--------------\r\n\r\nHere is Consumer behavior handlers of KVS FEEDS supervised processes\r\n\r\n```erlang\r\nhandle_notice(  [kvs_feed,user,Owner,entry,Eid,add],\r\n                [#entry{feed_id=Fid}=Entry],\r\n                #state{feeds=Feeds}) ->\r\n\r\n                case lists:keyfind(Fid,2, S#state.feeds) of\r\n                    false -> skip;\r\n                    {_,_} -> add_entry(Eid,Fid,Entry) end,\r\n                {noreply, S};\r\n\r\nhandle_notice(  [kvs_feed,user,Owner,entry,{Eid,FeedName},edit],\r\n                [#entry{feed_id=Fid}=Entry],\r\n                #state{feeds=Feeds}) ->\r\n\r\n                case lists:keyfind(FeedName,1,Feeds) of\r\n                    false -> skip;\r\n                    {_,Fid}-> update_entry(Eid,Fid,Entry) end,\r\n                {noreply, S};\r\n\r\nhandle_notice(  [kvs_feed,user,Owner,entry,Eid,edit],\r\n                [#entry{feed_id=Fid}=Entry],\r\n                #state{feeds=Feeds}) ->\r\n\r\n                case lists:keyfind(Fid, 2, Feeds) of\r\n                    false -> skip;\r\n                    {_,_} -> update_entry(Eid,Fid,Entry) end,\r\n                {noreply, S};\r\n```\r\n\r\nHere is the private implementation\r\n\r\n```erlang\r\nadd_entry(Eid,Fid,Entry) ->\r\n    E = Entry#entry{id = {Eid, Fid}, entry_id = Eid, feeds=[comments]},\r\n    Added = case kvs:add(E) of {error, Err} -> {error,Err}; {ok, En} -> En end,\r\n    msg:notify([kvs_feed, entry, {Eid, Fid}, added], [Added]).\r\n\r\nupdate_entry(Eid,Fid,Entry) -> ...\r\n```\r\n\r\nAnd that is how you can call it\r\n\r\n```erlang\r\nmsg:notify([kvs_feed, user, \"maxim@synrc.com\", entry, Eid, add], [#entry{}]).\r\n```\r\n\r\nCredits\r\n-------\r\n\r\n* Maxim Sokhatsky\r\n* Andrii Zadorozhnii\r\n* Vladimir Kirillov\r\n* Alex Kalenuk\r\n* Sergey Polkovnikov\r\n* Andrey Martemyanov\r\n\r\nOM A HUM\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}